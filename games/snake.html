<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Классическая змейка</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
        }
        canvas {
            border: 2px solid #333;
            background-color: #111;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        #score {
            font-size: 24px;
            margin-top: 10px;
            color: #333;
        }
        button {
            margin-top: 15px;
            padding: 10px 20px;
            font-size: 18px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #45a049;
        }
        #gameOver {
            font-size: 20px;
            color: red;
            margin-top: 10px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="400" height="400"></canvas>
    <div id="score">Счёт: 0</div>
    <div id="gameOver" style="display: none;">Игра окончена!</div>
    <button onclick="resetGame()">Новая игра</button>

    <script>
        // --- Получаем элементы ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const gameOverElement = document.getElementById('gameOver');

        // --- Параметры игры ---
        const gridSize = 20;          // размер клетки в пикселях
        const cellCount = 20;          // количество клеток по ширине/высоте (400/20 = 20)
        let snake = [];                // массив сегментов змеи {x, y}
        let direction = { dx: 1, dy: 0 };  // текущее направление движения
        let nextDirection = { dx: 1, dy: 0 };
        let food = { x: 10, y: 10 };   // позиция еды
        let score = 0;
        let gameActive = false;
        let gameInterval = null;

        // --- Инициализация начального состояния ---
        function initGame() {
            // Змея: три клетки в линию по горизонтали, голова справа
            snake = [
                { x: 10, y: 10 },
                { x: 9, y: 10 },
                { x: 8, y: 10 }
            ];
            direction = { dx: 1, dy: 0 };
            nextDirection = { dx: 1, dy: 0 };
            score = 0;
            updateScore();
            generateFood();  // создаём еду в свободном месте
            gameActive = true;
            gameOverElement.style.display = 'none';
        }

        // --- Генерация еды в случайной свободной клетке ---
        function generateFood() {
            const maxAttempts = 1000;
            for (let attempt = 0; attempt < maxAttempts; attempt++) {
                const newFood = {
                    x: Math.floor(Math.random() * cellCount),
                    y: Math.floor(Math.random() * cellCount)
                };
                // Проверяем, не занята ли клетка змеёй
                if (!snake.some(segment => segment.x === newFood.x && segment.y === newFood.y)) {
                    food = newFood;
                    return;
                }
            }
            // Если не нашли свободное место (почти всё поле занято) — завершаем игру победой
            gameActive = false;
            gameOverElement.textContent = 'Победа! Вы заполнили всё поле!';
            gameOverElement.style.display = 'block';
            clearInterval(gameInterval);
        }

        // --- Обновление счёта на экране ---
        function updateScore() {
            scoreElement.textContent = `Счёт: ${score}`;
        }

        // --- Проверка столкновения головы с телом или стенами ---
        function checkCollision(head) {
            // Столкновение со стенами
            if (head.x < 0 || head.x >= cellCount || head.y < 0 || head.y >= cellCount) {
                return true;
            }
            // Столкновение с телом (голова не должна совпадать ни с одним сегментом)
            return snake.some(segment => segment.x === head.x && segment.y === head.y);
        }

        // --- Основной шаг игры (вызывается по интервалу) ---
        function gameStep() {
            if (!gameActive) return;

            // Применяем следующее направление, если оно не противоположно текущему
            if ((nextDirection.dx !== 0 || nextDirection.dy !== 0) &&
                (direction.dx !== -nextDirection.dx || direction.dy !== -nextDirection.dy)) {
                direction = { ...nextDirection };
            }

            // Вычисляем новую голову
            const head = snake[0];
            const newHead = {
                x: head.x + direction.dx,
                y: head.y + direction.dy
            };

            // Проверяем, съедена ли еда
            const foodEaten = (newHead.x === food.x && newHead.y === food.y);

            // Добавляем новую голову в начало массива
            snake.unshift(newHead);

            if (foodEaten) {
                // Еда съедена: увеличиваем счёт, генерируем новую еду, хвост не удаляем
                score++;
                updateScore();
                generateFood();
            } else {
                // Еда не съедена: удаляем хвост
                snake.pop();
            }

            // Проверяем столкновение после всех изменений
            if (checkCollision(newHead)) {
                gameActive = false;
                gameOverElement.textContent = 'Игра окончена!';
                gameOverElement.style.display = 'block';
                clearInterval(gameInterval);
                return;
            }

            // Перерисовываем поле
            draw();
        }

        // --- Отрисовка игры ---
        function draw() {
            // Очищаем canvas
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Рисуем сетку (опционально)
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 0.5;
            for (let i = 0; i <= cellCount; i++) {
                ctx.beginPath();
                ctx.moveTo(i * gridSize, 0);
                ctx.lineTo(i * gridSize, canvas.height);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, i * gridSize);
                ctx.lineTo(canvas.width, i * gridSize);
                ctx.stroke();
            }

            // Рисуем змею
            snake.forEach((segment, index) => {
                // Голова ярче
                if (index === 0) {
                    ctx.fillStyle = '#00ff00';
                } else {
                    ctx.fillStyle = '#00aa00';
                }
                ctx.fillRect(segment.x * gridSize + 1, segment.y * gridSize + 1, gridSize - 2, gridSize - 2);
            });

            // Рисуем еду
            ctx.fillStyle = '#ff3333';
            ctx.beginPath();
            ctx.arc(food.x * gridSize + gridSize/2, food.y * gridSize + gridSize/2, gridSize/2 - 2, 0, Math.PI * 2);
            ctx.fill();
        }

        // --- Обработка нажатий клавиш ---
        function handleKeyDown(e) {
            if (!gameActive) return;

            const key = e.key;
            // Предотвращаем прокрутку страницы стрелками
            if (key.startsWith('Arrow')) {
                e.preventDefault();
            }

            switch (key) {
                case 'ArrowUp':
                    if (direction.dy !== 1)  // нельзя сразу развернуться вниз
                        nextDirection = { dx: 0, dy: -1 };
                    break;
                case 'ArrowDown':
                    if (direction.dy !== -1)
                        nextDirection = { dx: 0, dy: 1 };
                    break;
                case 'ArrowLeft':
                    if (direction.dx !== 1)
                        nextDirection = { dx: -1, dy: 0 };
                    break;
                case 'ArrowRight':
                    if (direction.dx !== -1)
                        nextDirection = { dx: 1, dy: 0 };
                    break;
            }
        }

        // --- Перезапуск игры ---
        function resetGame() {
            // Останавливаем старый интервал, если есть
            if (gameInterval) {
                clearInterval(gameInterval);
            }
            initGame();
            draw();
            // Запускаем новый интервал (скорость ~150 мс)
            gameInterval = setInterval(gameStep, 150);
        }

        // --- Запуск игры при загрузке страницы ---
        window.addEventListener('load', () => {
            resetGame();
            window.addEventListener('keydown', handleKeyDown);
        });

        // Дополнительно: делаем кнопку доступной глобально
        window.resetGame = resetGame;
    </script>
</body>
</html>